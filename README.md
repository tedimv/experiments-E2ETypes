# Project goals
The aims is to briefly explore options of creating end-to-end type safety between backend REST APIs and frontend clients by relying on automatic type generation since manually describing requests/responses/errors is not sustainable.

GraphQL has similar tools for generating types but it's not the focus of this experiment.

#### Progress report
The current solution is not 100% automatic but covers all major painpoints:
1. Reusing the openapi definitions generated by **Swashbuckle.AspNetCore**
2. Include potential error responses with their relevant codes to ensure all cases are handled
3. Reading+saving the schema on the client side through a script (**pnpm generate:types**)
4. Creating individual API request functions on the client based on the schema either manually or with AI

#### Painpoints
1. To get information on the error responses we need to use **ProducesResponseType** and **manually** describe every response variant which is not type checked by the compiler - throwing exceptions also does not work when trying to describe the failure states of the request
2. Payloads passed to **ProducesResponseType** need to have unique names, otherwise swagger's doc generation breaks
3. To work around C#'s lack of union types we need to use **IActionResult** when describing the endpoint return type which decreases readability 
4. Since throwing exceptions in C# is described purely with comments if a Manager/Service/Repository/etc. method changes the developer would need to **manually** check every place it's used and update the error responses if needed

<hr/>

### Monolith backend
The first test attemps to solve the problem for monolithic backends since schema discovery would be simpler

**API Project: Api** <br/>
**Client project: clients/web**

### Conclusions
1. Despite the manual descibing of the endpoint return types generation on both sides solves +90% of the complexity and is a great starting point to build on

<hr/>

### Microservices with DAPR

No data yet